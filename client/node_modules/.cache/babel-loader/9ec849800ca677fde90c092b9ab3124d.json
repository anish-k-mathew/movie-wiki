{"ast":null,"code":";\n\n(function (ctx) {\n  // These ranges will get used\n  // to 'automaticly' create the specific\n  // methods and options.\n  var RANGES = {\n    secondly: 1000,\n    minutely: 60000,\n    quarterly: 900000,\n    hourly: 3600000,\n    daily: 86400000,\n    weekly: 604800000\n  };\n\n  var limits = function limits(opts) {\n    // allow the 'new' keyword to be used or not..\n    if (!limits.prototype.isPrototypeOf(this)) {\n      return new limits(opts);\n    }\n\n    this.options = opts || {}; // In the 'track' array we save the\n    // timestamps of each call in history\n    // and the future. We need to store this\n    // information, otherwise we would not be\n    // able to calculate which delay the next call\n    // should have.\n\n    this.track = this.options.history || [];\n    this.rules = []; // Auto-Create the timerange options\n\n    for (var name in RANGES) {\n      if (!RANGES.hasOwnProperty(name)) continue;\n      if (name in this.options) this[name](this.options[name]);\n    }\n  }; // Determinate when the next call can be made.\n  // Returns an delay in milliseconds\n\n\n  limits.prototype.getNextDelay = function () {\n    return this._runRules().delay;\n  }; // Push a function into the call stack.\n  // Optionally a second conditional function\n  // can get passed in. The conditional function gets an 'delay'\n  // parameter passed in as first argument which indicates\n  // after how many milliseconds fn will get called.\n  // Returning false in the conditional function prevents\n  // fn from being added to the call stack.\n\n\n  limits.prototype.push = function (fn, cond) {\n    var delay = this.getNextDelay(),\n        that = this;\n\n    if (!this.rules.length) {\n      throw {\n        name: 'RuleError',\n        message: 'there are no defined rules'\n      };\n    }\n\n    if (typeof cond === 'function' && cond(delay) === false) {\n      return false;\n    }\n\n    this.track.push(Date.now() + delay);\n    return {\n      delay: delay,\n      timer: setTimeout(function () {\n        // Call the 'onCall' Callback if an entry\n        // gets added to the history.\n        if (typeof that.options.onCall === 'function') {\n          that.options.onCall(delay);\n        }\n\n        fn();\n      }, delay)\n    };\n  }; // Run through all rules and determinate when\n  // the next call can be made. Each rule\n  // also returns also a property 'spliceIdx'.\n  // spliceIdx indicates from which index\n  // on the track array can be safely cleared.\n\n\n  limits.prototype._runRules = function () {\n    var now = Date.now(),\n        memo = {\n      delay: 0\n    };\n\n    for (var i = 0, len = this.rules.length; i < len; i++) {\n      var comp = this.rules[i](now, this.track);\n\n      if (memo.delay < comp.delay) {\n        memo.delay = comp.delay;\n      }\n\n      if (!('spliceIdx' in memo) || memo.spliceIdx > comp.spliceIdx) {\n        memo.spliceIdx = comp.spliceIdx;\n      }\n    }\n\n    if ('spliceIdx' in memo && memo.spliceIdx > 0) {\n      if (typeof this.options.onClear === 'function') {\n        this.options.onClear(this.track[memo.spliceIdx]);\n      }\n\n      this.track.splice(0, memo.spliceIdx);\n    }\n\n    return memo;\n  }; // inspired by _.sortedIndex\n  // find the position in the sorted\n  // array 'this.track' where 'val'\n  // could be inserted\n\n\n  limits.prototype._getInsertPosition = function (val) {\n    var low = 0,\n        high = this.track.length;\n\n    while (low < high) {\n      var mid = low + high >>> 1;\n      this.track[mid] < val ? low = mid + 1 : high = mid;\n    }\n\n    return low;\n  }; // Register a new rule which indicates that within\n  // a period of 'millis' only a certain amount\n  // of 'maxcalls' can be made.\n\n\n  limits.prototype.within = function (millis, maxcalls) {\n    var that = this; // check if maxcalls is an integer and\n    // it is greater than 0\n\n    if (maxcalls % 1 !== 0 || maxcalls < 1) {\n      throw {\n        name: 'MaxcallsRangeError',\n        message: 'maxcalls must be above 0 and an integer'\n      };\n    }\n\n    this.register(function (now, track) {\n      var past = now - millis,\n          idx = that._getInsertPosition(past),\n          rest = track.length - idx,\n          delay = rest >= maxcalls ? track[idx + (rest - maxcalls)] + millis - now : 0;\n\n      return {\n        delay: delay,\n        spliceIdx: idx\n      };\n    });\n    return this;\n  }; // Create some methods out of our RANGES Object\n\n\n  for (var name in RANGES) {\n    if (!RANGES.hasOwnProperty(name)) continue;\n\n    (function (name) {\n      limits.prototype[name] = function (maxcalls) {\n        return this.within(RANGES[name], maxcalls);\n      };\n    })(name);\n  } // Register a custom rule.\n\n\n  limits.prototype.register = function (fn) {\n    this.rules.push(fn);\n    return this;\n  }; // Node.js / browserify\n\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = limits;\n  } // AMD\n  else if (typeof define !== 'undefined' && define.amd) {\n      define([], function () {\n        return limits;\n      });\n    } // <script>\n    else {\n        ctx.limits = limits;\n      }\n})(this);","map":null,"metadata":{},"sourceType":"script"}